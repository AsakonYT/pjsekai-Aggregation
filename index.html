<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ—ãƒ­ã‚»ã‚«é›†è¨ˆã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        :root{
            --bg:#222;
            --panel:#333;
            --panel-2:#444;
            --muted:#aaa;
            --text:#eee;
            --accent:#ff9900;
            --btn-bg:#444;
            --btn-text:#fff;
            --btn-accent:#ff9900;
        }
        .light-mode{
            --bg:#ffffff;
            --panel:#ffffff;
            --panel-2:#f0f0f0;
            --muted:#666666;
            --text:#000000;
            --accent:#cc7a00;
            --btn-bg:#f8f8f8;
            --btn-text:#000000;
            --btn-accent:#cc7a00;
        }
        .dark-mode{ /* default */
            --bg:#222;
            --panel:#333;
            --panel-2:#444;
            --muted:#aaa;
            --text:#eee;
            --accent:#ff9900;
            --btn-bg:#444;
            --btn-text:#fff;
            --btn-accent:#ff9900;
        }

        html,body{height:100%;}
        body { 
            background-color: var(--bg);
            color: var(--text);
            font-family: sans-serif; 
            padding: 20px; 
            margin: 0; 
        }
        
        #main_container {
            position: relative; 
            min-height: 100vh; 
            display: flex;
            flex-direction: column;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        #result_screen {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--bg);
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; 
            
            opacity: 0; 
            transition: opacity 0.5s ease-in-out; 
            pointer-events: none; 
            display: none; 
        }
        
        #result_screen.visible {
            opacity: 1;
            pointer-events: auto; 
        }
        
        h2, h3 { color: var(--text); border-bottom: 2px solid var(--panel-2); padding-bottom: 5px; margin-top: 30px; }
        .settings-group label { margin-right: 20px; display: inline-block; margin-bottom: 10px; }
        .settings-group input { background-color: var(--panel); border: 1px solid var(--panel-2); color: var(--text); padding: 5px; width: 80px; text-align: center; }
        
        .score-input-area {
            margin-top: 20px; display: grid; grid-template-columns: 100px repeat(5, 1fr); gap: 2px; background-color: var(--panel-2);
        }
        .row { display: contents; } 
        .header-row .label-col, .header-row .player-col { background-color: var(--panel); font-weight: bold; padding: 8px 5px; text-align: center; }
        .label-col { grid-column: 1; text-align: left; padding: 8px 5px; background-color: var(--panel); }
        .player-score { width: 90%; height: 30px; padding: 0; margin: 4px auto; display: block; text-align: center; background-color: var(--panel); border: 1px solid var(--panel-2); color: var(--text); }

        /* ãƒ¢ãƒã‚¤ãƒ«ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ– */
        
        button { padding: 10px 15px; margin-top: 20px; margin-right: 10px; border: 1px solid var(--panel-2); cursor: pointer; border-radius: 4px; background: var(--btn-bg); color: var(--btn-text); }
        .btn-accent{ background: var(--btn-accent); color: #000; border-color: rgba(0,0,0,0.15); }
        .toggle-switch { padding:6px 10px;border-radius:20px;min-width:120px;text-align:center }
        
        #reset_scores_button { background-color: #dc3545; color: white; }
        #show_intermediate_button { background-color: #007bff; color: white; }
        #show_single_song_result { background-color: #00a0a0; color: white; } 
        #confirm_song_score { background-color: #1e7e34; color: white; }
        #show_result_button { background-color: #e3a800; color: white; }
        #show_result_button:disabled { background-color: var(--panel-2); color: var(--muted); cursor: not-allowed;}
        
        #reset_game_button { background-color: #6c757d; color: white; }
        #undo_song_button { background-color: #ffc107; color: black; }
        
        #show_log_button { background-color: #5a6268; color: white; }

        #final_result_table { width: 100%; border-collapse: collapse; margin-top: 15px; color: var(--text); text-align: center; }
        #final_result_table th, #final_result_table td { border: 1px solid var(--panel-2); padding: 10px 5px; min-width: 80px; }
        #final_result_table th { background-color: var(--panel); }
        #final_result_table tbody tr td:first-child { font-weight: bold; text-align: left; background-color: var(--panel); }
        
        .total-row {
            font-weight: bold;
            background-color: var(--panel-2);
            color: var(--accent);
            font-size: 1.2em;
        }

        .count-total-row {
            font-weight: bold;
            background-color: var(--panel-2);
            color: var(--muted);
            font-size: 1.0em;
        }
        
        .first-place-column-cell {
            background-color: #383818 !important; 
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.5); 
            border-left: 2px solid #ffcc00 !important;
            border-right: 2px solid #ffcc00 !important;
        }
        .total-row .first-place-column-cell {
             background-color: #705500 !important;
        }
        .count-total-row .first-place-column-cell {
             background-color: #505030 !important;
        }
        .single-song-highlight-cell {
             background-color: #383818 !important; 
        }

        .rank-perfect {
            background-image: linear-gradient(to right, #e0b0ff, #ff6b8e); 
            -webkit-background-clip: text;
            color: transparent;
            font-weight: bold;
        }
        .rank-great { color: red; }
        .rank-good { color: deepskyblue; }
        .rank-bad { color: limegreen; } 
        .rank-miss { color: var(--muted); } 

        .hidden-value {
            visibility: hidden; 
        }
        .show-value .hidden-value {
            visibility: visible;
        }
        
        /* ãƒ­ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 10; 
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; 
            background-color: rgba(0,0,0,0.7); 
            padding-top: 50px;
        }

        .modal-content {
            background-color: var(--panel);
            margin: 5% auto; 
            padding: 20px;
            border: 1px solid var(--panel-2);
            width: 90%;
            max-width: 800px;
            border-radius: 8px;
        }

        .close-button {
            color: var(--muted);
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--text);
            text-decoration: none;
            cursor: pointer;
        }

        #log_content {
            height: 400px; 
            overflow-y: scroll;
            background-color: var(--panel);
            border: 1px solid var(--panel-2);
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 14px;
        }
        #log_content p {
            border-bottom: 1px dotted var(--panel-2);
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        .log-time { color: #888; margin-right: 10px; }
        .log-action { font-weight: bold; }
        .log-data { color: #ccc; }

        /* OBS WebSocketæ¥ç¶šãƒ‘ãƒãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .obs-connection-panel {
            background-color: var(--panel);
            border: 2px solid var(--panel-2);
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .obs-connection-panel h3 {
            margin-top: 0;
            color: var(--text);
            border-bottom: 1px solid var(--panel-2);
            padding-bottom: 10px;
        }

        .obs-settings-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .obs-settings-group label {
            display: flex;
            flex-direction: column;
            margin-bottom: 0;
        }

        .obs-settings-group label span {
            color: var(--muted);
            font-size: 12px;
            margin-bottom: 5px;
        }

        .obs-settings-group input {
            background-color: var(--panel);
            border: 1px solid var(--panel-2);
            color: var(--text);
            padding: 8px;
            border-radius: 3px;
        }

        .obs-connection-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        #obs_connect_button { background-color: #28a745; color: white; }
        #obs_connect_button:disabled { background-color: var(--panel-2); cursor: not-allowed; }
        #obs_disconnect_button { background-color: #dc3545; color: white; display: none; }

        .obs-status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background-color: var(--panel);
            border-radius: 4px;
            font-size: 14px;
        }

        .obs-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--muted);
            transition: background-color 0.3s;
        }

        .obs-status-dot.connected {
            background-color: #28a745;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.6);
        }

        .obs-status-dot.disconnected {
            background-color: #dc3545;
        }

        .obs-config-section {
            background-color: var(--panel);
            border: 1px solid var(--panel-2);
            border-radius: 4px;
            padding: 12px;
            margin-top: 10px;
        }

        .obs-config-section label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .obs-config-section label:last-child {
            margin-bottom: 0;
        }

        .obs-config-section input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .obs-log {
            background-color: var(--panel);
            border: 1px solid var(--panel-2);
            border-radius: 4px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 12px;
            font-family: monospace;
            color: var(--muted);
            margin-top: 10px;
        }

        .obs-log-entry {
            padding: 3px 0;
            border-bottom: 1px solid var(--panel-2);
        }

        .obs-log-entry:last-child {
            border-bottom: none;
        }

        .obs-log-entry.success { color: #28a745; }
        .obs-log-entry.error { color: #dc3545; }
        .obs-log-entry.info { color: #17a2b8; }
        
        /* ã‚°ãƒ©ãƒ•ã‚£ã‚«ãƒ«ãªãƒªã‚¶ãƒ«ãƒˆè¡¨ç¤ºï¼ˆãƒ—ãƒ­ã‚»ã‚«é¢¨ï¼‰ */
        .graphic-result {
            display: grid;
            grid-template-columns: 180px repeat(5, 1fr);
            gap: 10px;
            align-items: stretch;
            margin-top: 20px;
            color: #fff;
        }

        .graphic-result .label-col {
            background: #2b2b2b;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            justify-content: flex-start;
            border-radius: 6px;
            text-align: left;
            font-weight: bold;
        }

        .graphic-result .player-col {
            background: #3a3a3a;
            padding: 10px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .graphic-player-name {
            font-size: 18px;
            font-weight: bold;
            color: #f5f5f5;
        }

        .graphic-count {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            font-weight: 800;
            color: #ffd27a;
            background: rgba(0,0,0,0.12);
            border-radius: 6px;
            padding: 6px 8px;
            min-height: 44px;
        }

        .graphic-label { font-size: 16px; color: #cfcfcf; }

        .graphic-total { font-size: 34px; color: #ffcc66; background: rgba(0,0,0,0.18); }
    </style>
</head>
<body>

    <div id="main_container">
        <h2>è¨­å®š</h2>

        <div class="player-name-settings settings-group">
            <h3>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åè¨­å®š</h3>
            <label>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°: <select id="player_count_select">
                <option value="2">2äºº</option>
                <option value="3">3äºº</option>
                <option value="4">4äºº</option>
                <option value="5" selected>5äºº</option>
            </select></label>
            <label>P1 åå‰: <input type="text" id="name_1" value="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1"></label>
            <label>P2 åå‰: <input type="text" id="name_2" value="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2"></label>
            <label>P3 åå‰: <input type="text" id="name_3" value="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼3"></label>
            <label>P4 åå‰: <input type="text" id="name_4" value="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼4"></label>
            <label>P5 åå‰: <input type="text" id="name_5" value="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼5"></label>
        </div>

        <div class="total-songs-settings settings-group">
            <h3>ã‚²ãƒ¼ãƒ è¨­å®š</h3>
            <label>ç·æ›²æ•°: <input type="number" id="total_songs" value="5" min="1"></label>
        </div>

        <div class="obs-connection-panel">
            <h3>ğŸ¥ OBS WebSocketé€£æº</h3>
            
            <div class="obs-connection-buttons">
                <button id="obs_connect_button">æ¥ç¶š</button>
                <button id="obs_disconnect_button">åˆ‡æ–­</button>
                <div class="obs-status-indicator">
                    <div class="obs-status-dot disconnected" id="obs_status_dot"></div>
                    <span id="obs_status_text">æœªæ¥ç¶š</span>
                </div>
            </div>

            <div class="obs-settings-group">
                <label>
                    <span>WebSocketã‚¢ãƒ‰ãƒ¬ã‚¹</span>
                    <input type="text" id="obs_address" value="localhost" placeholder="localhost">
                </label>
                <label>
                    <span>ãƒãƒ¼ãƒˆç•ªå·</span>
                    <input type="number" id="obs_port" value="4455" min="1" max="65535">
                </label>
                <label>
                    <span>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ (OBSè¨­å®šã‚’ç¢ºèª)</span>
                    <input type="password" id="obs_password" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰">
                </label>
                <label style="visibility: hidden;">
                    <span></span>
                    <input type="text">
                </label>
            </div>

            <div class="obs-config-section">
                <label>
                    <input type="checkbox" id="obs_auto_sync" checked>
                    <span>ã‚¹ã‚³ã‚¢ç¢ºå®šæ™‚ã«è‡ªå‹•ã§OBSã«åŒæœŸã™ã‚‹</span>
                </label>
                <label>
                    <input type="checkbox" id="obs_show_results" checked>
                    <span>çµæœè¡¨ç¤ºæ™‚ã«ã‚·ãƒ¼ãƒ³è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆ (ã€ŒOBS-Resultsã€ã‚·ãƒ¼ãƒ³)</span>
                </label>
                <label>
                    <input type="checkbox" id="obs_hide_results" checked>
                    <span>å…¥åŠ›ç”»é¢ã«æˆ»ã‚‹æ™‚ã«ã‚·ãƒ¼ãƒ³è‡ªå‹•å¾©å¸° (ã€ŒOBS-Inputã€ã‚·ãƒ¼ãƒ³)</span>
                </label>
                <label>
                    <input type="checkbox" id="obs_send_detailed_data" checked>
                    <span>è©³ç´°ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã‚½ãƒ¼ã‚¹ã«é€ä¿¡ã™ã‚‹</span>
                </label>
            </div>

            <div class="obs-log" id="obs_log"></div>
        </div>

            <div style="margin-top:12px;display:flex;gap:8px;align-items:center;">
                <button id="open_history_button" class="toggle-switch">éå»ã®é›†è¨ˆã‚’è¦‹ã‚‹</button>
                <button id="save_snapshot_button" class="toggle-switch">ç¾åœ¨ã®é›†è¨ˆã‚’ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆä¿å­˜</button>
                <button id="toggle_theme_button" class="toggle-switch" style="margin-left:auto;">ãƒ†ãƒ¼ãƒåˆ‡æ›¿</button>
            </div>

        <div class="scoring-settings settings-group">
            <h3>é…ç‚¹è¨­å®š</h3>
            <label>Perfect: <input type="number" id="score_perfect" value="3"></label>
            <label>Great: <input type="number" id="score_great" value="2"></label>
            <label>Good: <input type="number" id="score_good" value="1"></label>
            <label>Bad: <input type="number" id="score_bad" value="0"></label>
            <label>Miss: <input type="number" id="score_miss" value="0"></label>
        </div>
        
        <div id="input_screen" class="screen">
            <h3>æ¡ç‚¹å…¥åŠ› (<span id="current_song_display">1</span> æ›²ç›® / å…¨ <span id="total_songs_display">5</span> æ›²)</h3>
            
            <div style="background-color: var(--panel); border: 1px solid var(--panel-2); padding: 15px; border-radius: 4px; margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 10px;">
                    <strong>æ¥½æ›²å (ã‚ªãƒ—ã‚·ãƒ§ãƒ³):</strong><br/>
                    <input type="text" id="song_name_input" placeholder="æ›²åã‚’å…¥åŠ›" style="width: 100%; padding: 8px; margin-top: 5px; box-sizing: border-box; background-color: var(--panel); border: 1px solid var(--panel-2); color: var(--text);">
                </label>
            </div>
            
            <button id="reset_scores_button">ç¾åœ¨ã®å…¥åŠ›ã‚’ã™ã¹ã¦0ã«æˆ»ã™</button>
            <button id="show_intermediate_button">ç¾åœ¨ã®å›æ•°ã‚’è¡¨ç¤º</button>
            <button id="show_single_song_result">ã“ã®æ›²ã®çµæœã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
            <button id="show_log_button">ğŸ“‹ å®Ÿè¡Œãƒ­ã‚°ã‚’è¡¨ç¤º</button>

            <hr style="margin: 20px 0; border-color: var(--panel-2);"> 
            <button id="confirm_song_score">âœ… ã“ã®æ›²ã®ã‚¹ã‚³ã‚¢ã‚’ç¢ºå®šã—ã€æ¬¡ã®æ›²ã¸é€²ã‚€</button>
            <button id="undo_song_button">â†©ï¸ ä¸€æ›²å‰ã«æˆ»ã‚‹ (æœ€æ–°ã®ã‚¹ã‚³ã‚¢ã‚’å‰Šé™¤)</button>
            <button id="show_result_button" disabled>ğŸ† å…¨æ›²ã®ç·åˆçµæœã‚’è¡¨ç¤º</button>

            <hr style="margin: 20px 0; border-color: var(--panel-2);">
            <button id="reset_game_button">ğŸ”„ ã‚²ãƒ¼ãƒ ã‚’æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã™ (æ›²æ•°ã¨ãƒ‡ãƒ¼ã‚¿ãƒªã‚»ãƒƒãƒˆ)</button>


            <div class="score-input-area">
                
                <div class="row header-row">
                    <span class="label-col">åˆ¤å®š</span>
                    <span class="player-col" id="header_p1_name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1</span>
                    <span class="player-col" id="header_p2_name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2</span>
                    <span class="player-col" id="header_p3_name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼3</span>
                    <span class="player-col" id="header_p4_name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼4</span>
                    <span class="player-col" id="header_p5_name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼5</span>
                </div>

                <div class="row"><span class="label-col rank-perfect">Perfect</span>
                    <input type="number" class="player-score" data-player="1" data-rank="perfect" value="0" min="0">
                    <input type="number" class="player-score" data-player="2" data-rank="perfect" value="0" min="0">
                    <input type="number" class="player-score" data-player="3" data-rank="perfect" value="0" min="0">
                    <input type="number" class="player-score" data-player="4" data-rank="perfect" value="0" min="0">
                    <input type="number" class="player-score" data-player="5" data-rank="perfect" value="0" min="0">
                </div>
                <div class="row"><span class="label-col rank-great">Great</span>
                    <input type="number" class="player-score" data-player="1" data-rank="great" value="0" min="0">
                    <input type="number" class="player-score" data-player="2" data-rank="great" value="0" min="0">
                    <input type="number" class="player-score" data-player="3" data-rank="great" value="0" min="0">
                    <input type="number" class="player-score" data-player="4" data-rank="great" value="0" min="0">
                    <input type="number" class="player-score" data-player="5" data-rank="great" value="0" min="0">
                </div>
                <div class="row"><span class="label-col rank-good">Good</span>
                    <input type="number" class="player-score" data-player="1" data-rank="good" value="0" min="0">
                    <input type="number" class="player-score" data-player="2" data-rank="good" value="0" min="0">
                    <input type="number" class="player-score" data-player="3" data-rank="good" value="0" min="0">
                    <input type="number" class="player-score" data-player="4" data-rank="good" value="0" min="0">
                    <input type="number" class="player-score" data-player="5" data-rank="good" value="0" min="0">
                </div>
                <div class="row"><span class="label-col rank-bad">Bad</span>
                    <input type="number" class="player-score" data-player="1" data-rank="bad" value="0" min="0">
                    <input type="number" class="player-score" data-player="2" data-rank="bad" value="0" min="0">
                    <input type="number" class="player-score" data-player="3" data-rank="bad" value="0" min="0">
                    <input type="number" class="player-score" data-player="4" data-rank="bad" value="0" min="0">
                    <input type="number" class="player-score" data-player="5" data-rank="bad" value="0" min="0">
                </div>
                <div class="row"><span class="label-col rank-miss">Miss</span>
                    <input type="number" class="player-score" data-player="1" data-rank="miss" value="0" min="0">
                    <input type="number" class="player-score" data-player="2" data-rank="miss" value="0" min="0">
                    <input type="number" class="player-score" data-player="3" data-rank="miss" value="0" min="0">
                    <input type="number" class="player-score" data-player="4" data-rank="miss" value="0" min="0">
                    <input type="number" class="player-score" data-player="5" data-rank="miss" value="0" min="0">
                </div>
                <div class="row"><span class="label-col" style="background-color: var(--panel-2); font-weight: bold;">ãƒãƒ¼ãƒ„æ•°ï¼ˆè‡ªå‹•è¨ˆç®—ï¼‰</span>
                    <input type="number" class="player-score" id="notes_1" data-player="1" value="0" min="0" readonly style="opacity: 0.7;">
                    <input type="number" class="player-score" id="notes_2" data-player="2" value="0" min="0" readonly style="opacity: 0.7;">
                    <input type="number" class="player-score" id="notes_3" data-player="3" value="0" min="0" readonly style="opacity: 0.7;">
                    <input type="number" class="player-score" id="notes_4" data-player="4" value="0" min="0" readonly style="opacity: 0.7;">
                    <input type="number" class="player-score" id="notes_5" data-player="5" value="0" min="0" readonly style="opacity: 0.7;">
                </div>
            </div>
            
            <div id="intermediate_result_container">
            </div>
        </div>


        <div id="result_screen" class="screen">
            <h3 id="result_title">ç·åˆçµæœ</h3>
            <button id="show_final_values_button" style="margin-bottom: 20px;">å›æ•°ã¨åˆè¨ˆã®æ•°å€¤ã‚’è¡¨ç¤º</button>
            <div id="final_result_table_container">
            </div>
            <div id="graphic_result_container"></div>
            <button id="back_to_input">å…¥åŠ›ç”»é¢ã«æˆ»ã‚‹</button>
        </div>
    </div>

    <div id="log_modal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="close_log_modal">&times;</span>
            <h3>å®Ÿè¡Œãƒ­ã‚° (æ“ä½œå±¥æ­´)</h3>
            <div id="log_content">
                </div>
            <button id="clear_log_button">ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢</button>
        </div>
    </div>

    <div id="history_modal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="close_history_modal">&times;</span>
            <h3>éå»ã®é›†è¨ˆå±¥æ­´</h3>
            <div id="history_content" style="max-height:420px;overflow:auto;background:var(--panel);padding:8px;border:1px solid var(--panel-2);border-radius:4px;margin-bottom:10px;"></div>
            <div style="display:flex;gap:8px;justify-content:flex-end;">
                <button id="export_all_history" style="background:#28a745;color:white;">ã™ã¹ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <button id="clear_history_button" style="background:#dc3545;color:white;">å±¥æ­´ã‚’å…¨ã¦å‰Šé™¤</button>
                <button id="close_history_ok" style="background:#6c757d;color:white;">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>

    <script>
        
        const RANKS = ['perfect', 'great', 'good', 'bad', 'miss']; 
        const NUM_PLAYERS = 5;
        
        // ğŸŒŸ localStorageã‚­ãƒ¼ã®å®šç¾© ğŸŒŸ
        const STORAGE_KEY_SONGS = 'pjskaiAggregation_songs';
        const STORAGE_KEY_CURRENT_SONG = 'pjskaiAggregation_currentSong';
        const STORAGE_KEY_LOG = 'pjskaiAggregation_log';
        const STORAGE_KEY_NAMES = 'pjskaiAggregation_names';
        const STORAGE_KEY_SETTINGS = 'pjskaiAggregation_settings';
        const STORAGE_KEY_OBS_SETTINGS = 'pjskaiAggregation_obsSettings';
        const STORAGE_KEY_HISTORY = 'pjskaiAggregation_history';
        const STORAGE_KEY_THEME = 'pjskaiAggregation_theme';
        
        const DEFAULT_NAMES = ["ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1", "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2", "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼3", "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼4", "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼5"];
        const DEFAULT_SONGS = 5;
        const DEFAULT_SCORES = { 
            'perfect': 3,
            'great': 2,
            'good': 1,
            'bad': 0,
            'miss': 0
        };
        
        let allSongsData = [];
        let currentSongNumber = 1; 
        let actionLog = [];
        let obsWebSocket = null;
        let obsConnected = false;
        let obsMessageId = 1;
        let obsLog = [];

        const RANK_CLASSES = {
            'perfect': 'rank-perfect',
            'great': 'rank-great',
            'good': 'rank-good',
            'bad': 'rank-bad',
            'miss': 'rank-miss'
        };

        // ===== OBS WebSocketé–¢é€£ã‚¯ãƒ©ã‚¹ =====
        class OBSWebSocketClient {
            constructor(address, port, password) {
                this.address = address;
                this.port = port;
                this.password = password;
                this.ws = null;
                this.messageId = 1;
                this.pendingRequests = new Map();
            }

            connect() {
                return new Promise((resolve, reject) => {
                    try {
                        const url = `ws://${this.address}:${this.port}`;
                        this.ws = new WebSocket(url);

                        this.ws.onopen = () => {
                            addOBSLog('æ¥ç¶šæˆåŠŸ', 'success');
                            resolve();
                        };

                        this.ws.onmessage = (event) => {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        };

                        this.ws.onerror = (error) => {
                            addOBSLog(`æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error && error.message ? error.message : error}`, 'error');
                            // do not reject here because onclose will follow
                        };

                        this.ws.onclose = (event) => {
                            const code = event && event.code ? event.code : 'N/A';
                            const reason = event && event.reason ? event.reason : '';
                            addOBSLog(`æ¥ç¶šã‚’åˆ‡æ–­ã—ã¾ã—ãŸ (code:${code}) ${reason}`, 'info');
                            obsConnected = false;
                            updateOBSStatusDisplay();
                            // reject if connection closed before resolve
                            reject(new Error('WebSocket closed'));
                        };
                    } catch (error) {
                        addOBSLog(`ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                        reject(error);
                    }
                });
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
            }

            handleMessage(data) {
                // ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯å‡¦ç†
                if (data.op === 0) { // Hello
                    // ãƒ­ã‚°ã«Helloå†…å®¹ã‚’è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                    try {
                        addOBSLog(`Helloå—ä¿¡: ${JSON.stringify(data.d).slice(0,200)}`, 'info');
                    } catch (e) {}
                    // éåŒæœŸã§èªè¨¼ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¦ã‹ã‚‰Identifyã‚’ç›´æ¥é€ä¿¡ã™ã‚‹ï¼ˆsendMessage ã‚’ä½¿ã†ã¨Responseã‚’å¾…ã£ã¦ã—ã¾ã„ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹ãŸã‚ï¼‰
                    (async () => {
                        try {
                            let auth = undefined;
                            if (data.d && data.d.authentication) {
                                auth = await this._generateAuth(data.d.authentication);
                            }
                            const identify = {
                                op: 1,
                                d: {
                                    rpcVersion: 1,
                                    authentication: auth,
                                    eventSubscriptions: 33
                                }
                            };
                            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                                this.ws.send(JSON.stringify(identify));
                                addOBSLog('Identifyé€ä¿¡æ¸ˆã¿', 'info');
                            } else {
                                addOBSLog('WebSocketãŒé–‹ã„ã¦ã„ãªã„ãŸã‚Identifyé€ä¿¡ã§ãã¾ã›ã‚“', 'error');
                            }
                        } catch (e) {
                            addOBSLog(`Identifyé€ä¿¡ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                        }
                    })();
                }
                // Identified/èªè¨¼æˆåŠŸ
                else if (data.op === 2) { // Identified
                    addOBSLog('èªè¨¼æˆåŠŸã€æ¥ç¶šå®Œäº†', 'success');
                    obsConnected = true;
                    updateOBSStatusDisplay();
                }
                // Response
                else if (data.op === 7) { // Response
                    const requestId = data.d.requestId;
                    if (this.pendingRequests.has(requestId)) {
                        const { resolve, reject } = this.pendingRequests.get(requestId);
                        this.pendingRequests.delete(requestId);
                        if (data.d.requestStatus.result) {
                            resolve(data.d.responseData);
                        } else {
                            reject(new Error(data.d.requestStatus.code));
                        }
                    }
                }
                // Event
                else if (data.op === 5) { // Event
                    // ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ãŒå¿…è¦ãªå ´åˆã¯ã“ã“ã«è¿½åŠ 
                }
            }

            _generateAuth(authChallenge) {
                if (!authChallenge) return undefined;

                const secret = this.password;
                const challenge = authChallenge.challenge;
                const salt = authChallenge.salt;

                // WebCrypto API ã‚’ä½¿ç”¨
                return new Promise(async (resolve) => {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(secret + salt);
                    const hash = await crypto.subtle.digest('SHA-256', data);
                    const secretHash = btoa(String.fromCharCode(...new Uint8Array(hash)));

                    const authData = encoder.encode(secretHash + challenge);
                    const authHash = await crypto.subtle.digest('SHA-256', authData);
                    const auth = btoa(String.fromCharCode(...new Uint8Array(authHash)));
                    resolve(auth);
                }).then(auth => auth);
            }

            sendMessage(message) {
                return new Promise((resolve, reject) => {
                    try {
                        const requestId = this.messageId++;
                        message.d = message.d || {};
                        message.d.requestId = requestId;

                        this.pendingRequests.set(requestId, { resolve, reject });
                        
                        setTimeout(() => {
                            if (this.pendingRequests.has(requestId)) {
                                this.pendingRequests.delete(requestId);
                                reject(new Error('Request timeout'));
                            }
                        }, 5000);

                        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.ws.send(JSON.stringify(message));
                        } else {
                            throw new Error('WebSocket is not connected');
                        }
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            async setSceneName(sceneName) {
                try {
                    await this.sendMessage({
                        op: 6,
                        d: {
                            requestType: 'SetCurrentProgramScene',
                            requestData: {
                                sceneName: sceneName
                            }
                        }
                    });
                    addOBSLog(`ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ: ${sceneName}`, 'success');
                } catch (error) {
                    addOBSLog(`ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆå¤±æ•—: ${error.message}`, 'error');
                }
            }

            async setSourceText(sourceName, text) {
                try {
                    await this.sendMessage({
                        op: 6,
                        d: {
                            requestType: 'SetInputSettings',
                            requestData: {
                                inputName: sourceName,
                                inputSettings: {
                                    text: text
                                }
                            }
                        }
                    });
                    addOBSLog(`ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°: ${sourceName}`, 'success');
                } catch (error) {
                    addOBSLog(`ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°å¤±æ•—: ${error.message}`, 'error');
                }
            }

            async setBrowserSourceHTML(sourceName, html) {
                try {
                    const dataUrl = 'data:text/html;charset=utf-8,' + encodeURIComponent(html);
                    await this.sendMessage({
                        op: 6,
                        d: {
                            requestType: 'SetInputSettings',
                            requestData: {
                                inputName: sourceName,
                                inputSettings: {
                                    url: dataUrl
                                }
                            }
                        }
                    });
                    addOBSLog(`ãƒ–ãƒ©ã‚¦ã‚¶ã‚½ãƒ¼ã‚¹æ›´æ–°: ${sourceName}`, 'success');
                } catch (error) {
                    addOBSLog(`ãƒ–ãƒ©ã‚¦ã‚¶ã‚½ãƒ¼ã‚¹æ›´æ–°å¤±æ•—: ${error.message}`, 'error');
                }
            }

            async getInputList() {
                try {
                    const res = await this.sendMessage({
                        op: 6,
                        d: {
                            requestType: 'GetInputList',
                            requestData: {}
                        }
                    });
                    return res.inputs || res; // v5å½¢å¼ãªã‚‰ {inputs: [...]}
                } catch (e) {
                    addOBSLog(`å…¥åŠ›ä¸€è¦§å–å¾—å¤±æ•—: ${e.message}`, 'error');
                    return [];
                }
            }
        }

        function addOBSLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            obsLog.push({ message, type, timestamp });
            
            if (obsLog.length > 20) {
                obsLog.shift();
            }

            updateOBSLogDisplay();
        }

        function updateOBSLogDisplay() {
            const logContainer = document.getElementById('obs_log');
            logContainer.innerHTML = obsLog.map(log => 
                `<div class="obs-log-entry ${log.type}">[${log.timestamp}] ${log.message}</div>`
            ).join('');
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function updateOBSStatusDisplay() {
            const statusDot = document.getElementById('obs_status_dot');
            const statusText = document.getElementById('obs_status_text');
            const connectBtn = document.getElementById('obs_connect_button');
            const disconnectBtn = document.getElementById('obs_disconnect_button');

            if (obsConnected) {
                statusDot.classList.remove('disconnected');
                statusDot.classList.add('connected');
                statusText.textContent = 'æ¥ç¶šæ¸ˆã¿';
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'block';
            } else {
                statusDot.classList.remove('connected');
                statusDot.classList.add('disconnected');
                statusText.textContent = 'æœªæ¥ç¶š';
                connectBtn.style.display = 'block';
                disconnectBtn.style.display = 'none';
            }
        }

        function loadOBSSettings() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY_OBS_SETTINGS);
                if (stored) {
                    const settings = JSON.parse(stored);
                    document.getElementById('obs_address').value = settings.address || 'localhost';
                    document.getElementById('obs_port').value = settings.port || '4455';
                    document.getElementById('obs_password').value = settings.password || '';
                    document.getElementById('obs_auto_sync').checked = settings.autoSync !== false;
                    document.getElementById('obs_show_results').checked = settings.showResults !== false;
                    document.getElementById('obs_hide_results').checked = settings.hideResults !== false;
                    document.getElementById('obs_send_detailed_data').checked = settings.sendDetailedData !== false;
                }
            } catch (e) {
                console.error("OBSè¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—", e);
            }
        }

        function saveOBSSettings() {
            try {
                const settings = {
                    address: document.getElementById('obs_address').value,
                    port: parseInt(document.getElementById('obs_port').value),
                    password: document.getElementById('obs_password').value,
                    autoSync: document.getElementById('obs_auto_sync').checked,
                    showResults: document.getElementById('obs_show_results').checked,
                    hideResults: document.getElementById('obs_hide_results').checked,
                    sendDetailedData: document.getElementById('obs_send_detailed_data').checked
                };
                localStorage.setItem(STORAGE_KEY_OBS_SETTINGS, JSON.stringify(settings));
            } catch (e) {
                console.error("OBSè¨­å®šã®ä¿å­˜ã«å¤±æ•—", e);
            }
        }

        async function connectToOBS() {
            try {
                const address = document.getElementById('obs_address').value;
                const port = parseInt(document.getElementById('obs_port').value);
                const password = document.getElementById('obs_password').value;

                if (!address || !port) {
                    addOBSLog('ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒãƒ¼ãƒˆç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                    return;
                }

                addOBSLog('OBSã«æ¥ç¶šä¸­...', 'info');
                obsWebSocket = new OBSWebSocketClient(address, port, password);
                
                await obsWebSocket.connect();
                saveOBSSettings();
                updateOBSStatusDisplay();
                addOBSLog('æ¥ç¶šå®Œäº†ã€‚è¡¨ç¤ºåæ˜ ã¯ã€Œå›æ•°ã¨åˆè¨ˆã®æ•°å€¤ã‚’è¡¨ç¤ºã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„', 'info');
                // æ¥ç¶šå¾Œã¯Identifyå¿œç­”ï¼ˆop:2ï¼‰ãŒæ¥ã‚‹ã¾ã§å¾…ã¤ã€‚æ¥ã¦ã‹ã‚‰OBSæ“ä½œã‚’è¡Œã†ã€‚
                const startWait = Date.now();
                const waited = await new Promise(resolve => {
                    const iv = setInterval(() => {
                        if (obsConnected) {
                            clearInterval(iv);
                            resolve(true);
                        }
                        if (Date.now() - startWait > 5000) {
                            clearInterval(iv);
                            resolve(false);
                        }
                    }, 200);
                });

                if (waited) {
                    // ãƒ‡ãƒãƒƒã‚°: æ¥ç¶šå¾Œã«OBSã®å…¥åŠ›(ã‚½ãƒ¼ã‚¹)ä¸€è¦§ã‚’å–å¾—ã—ã¦ãƒ­ã‚°è¡¨ç¤º
                    try {
                        const inputs = await obsWebSocket.getInputList();
                        if (Array.isArray(inputs)) {
                            const names = inputs.map(i => i.inputName || i.input_name || i.name).filter(Boolean);
                            addOBSLog(`OBSå…¥åŠ›ä¸€è¦§: ${names.join(', ')}`, 'info');
                        } else {
                            addOBSLog('OBSå…¥åŠ›ä¸€è¦§ã‚’å–å¾—ã—ã¾ã—ãŸãŒã€å½¢å¼ãŒä¸æ˜ã§ã™', 'info');
                        }
                    } catch (e) {
                        addOBSLog(`å…¥åŠ›ä¸€è¦§å–å¾—ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                    }
                } else {
                    addOBSLog('Identifyå¿œç­”ã‚’å¾…æ©Ÿä¸­ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§å†åŒæœŸã—ã¦ãã ã•ã„', 'error');
                }
            } catch (error) {
                addOBSLog(`æ¥ç¶šå¤±æ•—: ${error.message}`, 'error');
                obsWebSocket = null;
                obsConnected = false;
                updateOBSStatusDisplay();
            }
        }

        function disconnectFromOBS() {
            if (obsWebSocket) {
                obsWebSocket.disconnect();
                obsWebSocket = null;
                obsConnected = false;
                updateOBSStatusDisplay();
            }
        }

        async function syncResultsToOBS(playerData, isOverall = false) {
            if (!obsConnected || !obsWebSocket) {
                return;
            }

            try {
                if (document.getElementById('obs_send_detailed_data').checked) {
                    const resultData = {
                        timestamp: new Date().toISOString(),
                        type: isOverall ? 'overall' : 'single_song',
                        currentSong: currentSongNumber,
                        totalSongs: parseInt(document.getElementById('total_songs').value),
                        results: playerData.map(p => ({
                            name: p.name,
                            score: p.totalScore,
                            counts: p.counts || p.totalCounts
                        }))
                    };

                    const resultText = JSON.stringify(resultData);
                    await obsWebSocket.setSourceText('çµæœãƒ‡ãƒ¼ã‚¿', resultText);
                }

                // è©³ç´°ãªçµæœãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆï¼ˆå„ãƒ©ãƒ³ã‚¯ã®ã‚«ã‚¦ãƒ³ãƒˆæ•°ã‚’å«ã‚€ï¼‰
                const resultTexts = playerData
                    .sort((a, b) => b.totalScore - a.totalScore)
                    .map(p => {
                        const counts = p.counts || p.totalCounts;
                        const countString = counts ? 
                            `P:${counts.perfect || 0} G:${counts.great || 0} Go:${counts.good || 0} B:${counts.bad || 0} M:${counts.miss || 0}` :
                            '';
                        return `${p.name}\n${countString}\nTOTAL: ${p.totalScore}ç‚¹`;
                    })
                    .join('\n\n');

                await obsWebSocket.setSourceText('ã‚¹ã‚³ã‚¢è¡¨ç¤º', resultTexts);

                // ã•ã‚‰ã«BrowserSourceã«HTMLã§è¡¨ç¤ºã—ãŸã„å ´åˆï¼ˆresult_overlay ã¨ã„ã†Browser Sourceã‚’ä½œæˆã—ã¦ãŠãï¼‰
                try {
                    if (document.getElementById('obs_show_results').checked) {
                        const overlayHtml = buildResultOverlayHTML(playerData, isOverall);
                        await obsWebSocket.setBrowserSourceHTML('result_overlay', overlayHtml);
                    }
                } catch (e) {
                    addOBSLog(`ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ›´æ–°å¤±æ•—: ${e.message}`, 'error');
                }

            } catch (error) {
                addOBSLog(`ãƒ‡ãƒ¼ã‚¿é€ä¿¡å¤±æ•—: ${error.message}`, 'error');
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            
            // ğŸŒŸ ãƒ‡ãƒ¼ã‚¿ã®ãƒ­ãƒ¼ãƒ‰ ğŸŒŸ
            loadData();
            loadOBSSettings();

            document.getElementById('result_screen').style.display = 'none';
            
            const totalSongsInput = document.getElementById('total_songs');
            const totalSongsDisplay = document.getElementById('total_songs_display');
            
            const updateTotalSongs = () => {
                const total = parseInt(totalSongsInput.value) || 1;
                totalSongsInput.value = total;
                totalSongsDisplay.textContent = total;
                updateOverallResultButtonStatus();
                saveSettings(); // è¨­å®šå¤‰æ›´æ™‚ã«ä¿å­˜
            };
            
            // è¨­å®šå€¤ã®å¤‰æ›´ã‚’ç›£è¦–ã—ã¦ä¿å­˜
            totalSongsInput.addEventListener('change', updateTotalSongs);
            
            RANKS.forEach(rank => {
                 document.getElementById(`score_${rank}`).addEventListener('change', saveSettings);
            });

            // OBSè¨­å®šã®å¤‰æ›´ã‚’ç›£è¦–
            ['obs_address', 'obs_port', 'obs_password', 'obs_auto_sync', 'obs_show_results', 'obs_hide_results', 'obs_send_detailed_data'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', saveOBSSettings);
                }
            });

            // OBSæ¥ç¶šãƒœã‚¿ãƒ³ã®ãƒªã‚¹ãƒŠãƒ¼
            document.getElementById('obs_connect_button').addEventListener('click', connectToOBS);
            document.getElementById('obs_disconnect_button').addEventListener('click', disconnectFromOBS);
            
            updateTotalSongs(); 
            updateOBSStatusDisplay();
            
            document.getElementById('current_song_display').textContent = currentSongNumber;


            document.getElementById('show_result_button').addEventListener('click', calculateAndShowOverallResults);
            document.getElementById('show_intermediate_button').addEventListener('click', calculateIntermediateResults); 
            document.getElementById('show_single_song_result').addEventListener('click', calculateAndShowSingleSongResult); 
            document.getElementById('back_to_input').addEventListener('click', showInputScreen);
            document.getElementById('reset_scores_button').addEventListener('click', resetCurrentScores); 
            document.getElementById('confirm_song_score').addEventListener('click', confirmSongScore);
            document.getElementById('show_final_values_button').addEventListener('click', showFinalValues);
            document.getElementById('reset_game_button').addEventListener('click', resetGame);
            document.getElementById('undo_song_button').addEventListener('click', undoSong);
            
            document.getElementById('show_log_button').addEventListener('click', showLog);
            document.getElementById('close_log_modal').addEventListener('click', hideLog);
            document.getElementById('clear_log_button').addEventListener('click', clearLog);
            
            // æ¥½æ›²åå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‡¦ç†
            const songNameInput = document.getElementById('song_name_input');
            if (songNameInput) {
                songNameInput.addEventListener('change', saveSongName);
            }
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚»ãƒ¬ã‚¯ã‚¿ã®å‡¦ç†
            const playerCountSelect = document.getElementById('player_count_select');
            if (playerCountSelect) {
                playerCountSelect.addEventListener('change', updatePlayerCount);
            }
            
            // ã‚¹ã‚³ã‚¢å…¥åŠ›æ™‚ã«ãƒãƒ¼ãƒ„æ•°ã‚’è‡ªå‹•è¨ˆç®—
            const playerScoreInputs = document.querySelectorAll('.player-score[data-rank]');
            playerScoreInputs.forEach(input => {
                input.addEventListener('change', updateNotesDisplay);
                input.addEventListener('input', updateNotesDisplay);
            });
            
            window.addEventListener('click', (event) => {
                if (event.target === document.getElementById('log_modal')) {
                    hideLog();
                }
            });


            for (let i = 1; i <= NUM_PLAYERS; i++) {
                const inputElement = document.getElementById(`name_${i}`);
                const headerElement = document.getElementById(`header_p${i}_name`);
                
                // ãƒ­ãƒ¼ãƒ‰å¾Œã«åå‰ã‚’è¨­å®š
                headerElement.textContent = inputElement.value || `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${i}`;
                
                inputElement.addEventListener('input', (event) => {
                    headerElement.textContent = event.target.value || `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${i}`;
                    saveNames(); // åå‰å¤‰æ›´æ™‚ã«ä¿å­˜
                });
            }

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    if (document.getElementById('result_screen').classList.contains('visible')) {
                         showInputScreen();
                    }
                    if (document.getElementById('log_modal').style.display === 'block') {
                        hideLog();
                    }
                }
            });

            setupArrowKeyNavigation();
            
            // åˆæœŸãƒ­ã‚°ï¼ˆãƒ­ãƒ¼ãƒ‰å¾Œã«å®Ÿè¡Œï¼‰
            if (actionLog.length === 0) {
                 logAction('ã‚·ã‚¹ãƒ†ãƒ ', 'ã‚¢ãƒ—ãƒªèµ·å‹• (æ–°è¦ãƒ‡ãƒ¼ã‚¿)');
            }

            // å±¥æ­´ãƒ‘ãƒãƒ«ã®ãƒœã‚¿ãƒ³è¨­å®š
            const openHistoryBtn = document.getElementById('open_history_button');
            if (openHistoryBtn) openHistoryBtn.addEventListener('click', function(){ document.getElementById('history_modal').style.display = 'block'; renderAggregationHistory(); });
            const saveSnapBtn = document.getElementById('save_snapshot_button');
            if (saveSnapBtn) saveSnapBtn.addEventListener('click', saveSnapshot);
            const closeHistoryBtn = document.getElementById('close_history_modal');
            if (closeHistoryBtn) closeHistoryBtn.addEventListener('click', hideHistory);
            const closeHistoryOk = document.getElementById('close_history_ok');
            if (closeHistoryOk) closeHistoryOk.addEventListener('click', hideHistory);
            const exportAllBtn = document.getElementById('export_all_history');
            if (exportAllBtn) exportAllBtn.addEventListener('click', exportAllHistory);
            const clearHistoryBtn = document.getElementById('clear_history_button');
            if (clearHistoryBtn) clearHistoryBtn.addEventListener('click', clearHistory);
            const themeToggleBtn = document.getElementById('toggle_theme_button');
            if (themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme);

            // apply saved theme immediately
            try { const t = loadTheme() || 'dark'; applyTheme(t); } catch(e){}

            window.addEventListener('click', (event) => {
                if (event.target === document.getElementById('log_modal')) {
                    hideLog();
                }
                if (event.target === document.getElementById('history_modal')) {
                    hideHistory();
                }
            });
        });
        
        // ----------------------------------------------------
        // ğŸŒŸ ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ– (localStorage) é–¢é€£é–¢æ•° ğŸŒŸ
        // ----------------------------------------------------

        function saveData() {
            try {
                // æ›²ãƒ‡ãƒ¼ã‚¿ã¨ç¾åœ¨ã®æ›²æ•°ã‚’ä¿å­˜
                localStorage.setItem(STORAGE_KEY_SONGS, JSON.stringify(allSongsData));
                localStorage.setItem(STORAGE_KEY_CURRENT_SONG, currentSongNumber.toString());

                // ãƒ­ã‚°ã‚’ä¿å­˜
                localStorage.setItem(STORAGE_KEY_LOG, JSON.stringify(actionLog));
                
                // logAction('ã‚·ã‚¹ãƒ†ãƒ ', 'ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•ä¿å­˜'); // è‡ªå‹•ä¿å­˜ã®é »åº¦ãŒé«˜ã„ã®ã§ã€ãƒ­ã‚°ã«ã¯æ®‹ã•ãªã„
            } catch (e) {
                console.error("ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ", e);
                alert("ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒæº€æ¯ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚");
            }
        }
        
        function saveSongName() {
            const songName = document.getElementById('song_name_input').value.trim();
            if (allSongsData[currentSongNumber - 1]) {
                allSongsData[currentSongNumber - 1].songName = songName;
                saveData();
            }
        }
        
        function loadSongName() {
            if (allSongsData[currentSongNumber - 1] && allSongsData[currentSongNumber - 1].songName) {
                document.getElementById('song_name_input').value = allSongsData[currentSongNumber - 1].songName;
            } else {
                document.getElementById('song_name_input').value = '';
            }
        }
        
        function updateNotesDisplay() {
            // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒãƒ¼ãƒ„æ•°ã‚’æ›´æ–°
            for (let p = 1; p <= NUM_PLAYERS; p++) {
                let totalNotes = 0;
                RANKS.forEach(rank => {
                    const input = document.querySelector(`.player-score[data-player="${p}"][data-rank="${rank}"]`);
                    if (input) {
                        totalNotes += parseInt(input.value) || 0;
                    }
                });
                
                // ãƒãƒ¼ãƒ„æ•°ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°
                const notesInput = document.getElementById(`notes_${p}`);
                if (notesInput) {
                    notesInput.value = totalNotes;
                }
            }
        }
        
        function saveNames() {
            const names = {};
            for (let i = 1; i <= NUM_PLAYERS; i++) {
                names[i] = document.getElementById(`name_${i}`).value;
            }
            localStorage.setItem(STORAGE_KEY_NAMES, JSON.stringify(names));
        }

        function saveSettings() {
             const settings = {
                totalSongs: document.getElementById('total_songs').value,
                scores: {}
            };
            RANKS.forEach(rank => {
                settings.scores[rank] = document.getElementById(`score_${rank}`).value;
            });
            localStorage.setItem(STORAGE_KEY_SETTINGS, JSON.stringify(settings));
        }

        function loadData() {
            try {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã®ãƒ­ãƒ¼ãƒ‰
                const storedNames = localStorage.getItem(STORAGE_KEY_NAMES);
                if (storedNames) {
                    const names = JSON.parse(storedNames);
                    for (let i = 1; i <= NUM_PLAYERS; i++) {
                        document.getElementById(`name_${i}`).value = names[i] || DEFAULT_NAMES[i-1];
                    }
                }

                // è¨­å®šã®ãƒ­ãƒ¼ãƒ‰
                const storedSettings = localStorage.getItem(STORAGE_KEY_SETTINGS);
                if (storedSettings) {
                    const settings = JSON.parse(storedSettings);
                    document.getElementById('total_songs').value = settings.totalSongs || DEFAULT_SONGS;
                    RANKS.forEach(rank => {
                         document.getElementById(`score_${rank}`).value = settings.scores[rank] || DEFAULT_SCORES[rank];
                    });
                }
                
                // æ›²ãƒ‡ãƒ¼ã‚¿ã®ãƒ­ãƒ¼ãƒ‰
                const storedSongs = localStorage.getItem(STORAGE_KEY_SONGS);
                if (storedSongs) {
                    allSongsData = JSON.parse(storedSongs);
                }

                // ç¾åœ¨ã®æ›²æ•°ã®ãƒ­ãƒ¼ãƒ‰
                const storedSongNumber = localStorage.getItem(STORAGE_KEY_CURRENT_SONG);
                if (storedSongNumber) {
                    currentSongNumber = parseInt(storedSongNumber);
                }

                // ãƒ­ã‚°ã®ãƒ­ãƒ¼ãƒ‰
                const storedLog = localStorage.getItem(STORAGE_KEY_LOG);
                if (storedLog) {
                    actionLog = JSON.parse(storedLog);
                }
                
                if (allSongsData.length > 0 || currentSongNumber > 1) {
                    logAction('ã‚·ã‚¹ãƒ†ãƒ ', 'ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã€å¾©å…ƒã—ã¾ã—ãŸ');
                }
                
            } catch (e) {
                console.error("ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ", e);
                alert("ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ¼ã‚¿ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚");
                // å¤±æ•—ã—ãŸå ´åˆã¯åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
                allSongsData = [];
                currentSongNumber = 1;
            }
        }

        // ----------------------------------------------------
        // å±¥æ­´ï¼ˆã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼‰è¡¨ç¤ºã¨ç®¡ç†
        // ----------------------------------------------------

        function loadHistory() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY_HISTORY);
                return raw ? JSON.parse(raw) : [];
            } catch (e) {
                console.error('å±¥æ­´èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼', e);
                return [];
            }
        }

        function saveHistory(history) {
            localStorage.setItem(STORAGE_KEY_HISTORY, JSON.stringify(history));
        }

        function saveSnapshot() {
            const history = loadHistory();
            const names = {};
            for (let i = 1; i <= NUM_PLAYERS; i++) names[i] = document.getElementById(`name_${i}`).value || `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${i}`;

            const snapshot = {
                id: Date.now(),
                ts: (new Date()).toISOString(),
                names: names,
                songs: JSON.parse(JSON.stringify(allSongsData || [])),
                currentSongNumber: currentSongNumber
            };

            history.push(snapshot);
            saveHistory(history);
            renderAggregationHistory();
            alert('ç¾åœ¨ã®é›†è¨ˆã‚’ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸ');
        }

        function renderAggregationHistory() {
            const container = document.getElementById('history_content');
            if (!container) return;
            const history = loadHistory();
            container.innerHTML = '';
            if (!history || history.length === 0) {
                container.innerHTML = '<div style="padding:12px;color:#ccc">å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ç¾åœ¨ã®é›†è¨ˆã‚’ã€Œã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆä¿å­˜ã€ã—ã¦ãã ã•ã„ã€‚</div>';
                return;
            }

            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.color = 'var(--text)';

            const thead = table.createTHead();
            const hr = thead.insertRow();
            ['æ—¥æ™‚','æ›²æ•°','æ¦‚è¦','æ“ä½œ'].forEach(h => { const th = document.createElement('th'); th.textContent = h; th.style.padding='6px'; th.style.borderBottom='1px solid var(--panel-2)'; th.style.textAlign='left'; hr.appendChild(th); });

            const tbody = table.createTBody();
            history.slice().reverse().forEach((snap, idxRev) => {
                const row = tbody.insertRow();
                row.style.borderBottom = '1px solid var(--panel-2)';
                const dateCell = row.insertCell();
                dateCell.style.padding='8px';
                dateCell.textContent = (new Date(snap.ts)).toLocaleString();

                const songCell = row.insertCell();
                songCell.style.padding='8px';
                songCell.textContent = (snap.songs && snap.songs.length) ? snap.songs.length + ' æ›²' : '0 æ›²';

                const summaryCell = row.insertCell();
                summaryCell.style.padding='8px';
                // build small summary: totals per player for quick scan
                const totals = {};
                if (snap.songs && snap.songs.length) {
                    snap.songs.forEach(s => {
                        s.scores.forEach(p => {
                            totals[p.id] = (totals[p.id] || 0) + (p.totalScore || 0);
                        });
                    });
                }
                const summaryParts = [];
                for (let i = 1; i <= NUM_PLAYERS; i++) {
                    summaryParts.push((snap.names && snap.names[i]) ? snap.names[i] + ':' + (totals[i]||0) : `P${i}:${totals[i]||0}`);
                }
                summaryCell.textContent = summaryParts.join(' | ');

                const actionCell = row.insertCell();
                actionCell.style.padding='8px';
                actionCell.style.textAlign='right';

                const viewBtn = document.createElement('button');
                viewBtn.textContent = 'è¡¨ç¤º';
                viewBtn.style.marginRight='6px';
                viewBtn.addEventListener('click', function(){ viewSnapshot(history.length - 1 - idxRev); });
                actionCell.appendChild(viewBtn);

                const exportBtn = document.createElement('button');
                exportBtn.textContent = 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ';
                exportBtn.style.marginRight='6px';
                exportBtn.addEventListener('click', function(){ exportSnapshot(history.length - 1 - idxRev); });
                actionCell.appendChild(exportBtn);

                const delBtn = document.createElement('button');
                delBtn.textContent = 'å‰Šé™¤';
                delBtn.style.background='#dc3545'; delBtn.style.color='white';
                delBtn.addEventListener('click', function(){ deleteSnapshot(history.length - 1 - idxRev); });
                actionCell.appendChild(delBtn);
            });

            container.appendChild(table);
        }

        function viewSnapshot(index) {
            const history = loadHistory();
            const snap = history[index];
            if (!snap) { alert('å±¥æ­´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ'); return; }

            // restore names and songs temporarily, then render overall result
            for (let i = 1; i <= NUM_PLAYERS; i++) {
                document.getElementById(`name_${i}`).value = snap.names[i] || `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${i}`;
                document.getElementById(`header_p${i}_name`).textContent = snap.names[i] || `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${i}`;
            }

            // set allSongsData to snapshot and render overall
            allSongsData = JSON.parse(JSON.stringify(snap.songs || []));
            currentSongNumber = snap.currentSongNumber || 1;
            generateResultTable(getOverallPlayerData(), `å±¥æ­´: ${(new Date(snap.ts)).toLocaleString()}`, 'overall');
            hideHistory();
        }

        function exportSnapshot(index) {
            const history = loadHistory();
            const snap = history[index];
            if (!snap) { alert('å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“'); return; }
            const blob = new Blob([JSON.stringify(snap, null, 2)], {type:'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pjskai_snapshot_${snap.id}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        function deleteSnapshot(index) {
            if (!confirm('ã“ã®å±¥æ­´ã‚’å‰Šé™¤ã—ã¦ã‚ˆã„ã§ã™ã‹ï¼Ÿ')) return;
            const history = loadHistory();
            history.splice(index,1);
            saveHistory(history);
            renderAggregationHistory();
        }

        function exportAllHistory() {
            const history = loadHistory();
            if (!history || history.length === 0) { alert('å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“'); return; }
            const blob = new Blob([JSON.stringify(history, null, 2)], {type:'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pjskai_history_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        function clearHistory() {
            if (!confirm('å±¥æ­´ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) return;
            saveHistory([]);
            renderAggregationHistory();
        }

        function hideHistory() {
            document.getElementById('history_modal').style.display = 'none';
        }

        // ----------------------------------------------------
        // ãƒ†ãƒ¼ãƒåˆ‡æ›¿æ©Ÿèƒ½
        // ----------------------------------------------------
        function loadTheme() {
            try { return localStorage.getItem(STORAGE_KEY_THEME) || 'dark'; } catch(e){return 'dark';}
        }
        function saveTheme(theme) { try { localStorage.setItem(STORAGE_KEY_THEME, theme); } catch(e){} }
        function applyTheme(theme) {
            document.documentElement.classList.remove('light-mode','dark-mode');
            if (theme === 'light') document.documentElement.classList.add('light-mode');
            else document.documentElement.classList.add('dark-mode');
            const btn = document.getElementById('toggle_theme_button');
            if (btn) btn.textContent = theme === 'light' ? 'ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰' : 'ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰';
        }
        function toggleTheme() {
            const current = loadTheme();
            const next = current === 'light' ? 'dark' : 'light';
            saveTheme(next);
            applyTheme(next);
        }
        /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆåˆ‡æ›¿ï¼ˆãƒ¢ãƒã‚¤ãƒ«ï¼‰æ©Ÿèƒ½ã¯å»ƒæ­¢ */
        
        // ----------------------------------------------------
        // ğŸŒŸ ãƒ­ã‚°é–¢é€£é–¢æ•° (å¤‰æ›´ãªã—) ğŸŒŸ
        // ----------------------------------------------------

        function logAction(actor, action, data = null) {
            const now = new Date();
            const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            
            let dataString = '';
            if (data) {
                if (typeof data === 'object' && !Array.isArray(data)) {
                    dataString = JSON.stringify(data, null, 2);
                } else if (Array.isArray(data)) {
                     dataString = JSON.stringify(data.map(d => `${d.name || d.id}: ${d.totalScore || d.score || d.action}`), null, 2);
                } else {
                    dataString = String(data);
                }
            }

            actionLog.push({
                time: timeString,
                actor: actor,
                action: action,
                data: dataString
            });
            
            if (actionLog.length > 200) { 
                actionLog.shift();
            }
            
            saveData(); // ãƒ­ã‚°ãŒæ›´æ–°ã•ã‚ŒãŸã‚‰å³åº§ã«ä¿å­˜
        }
        
        function showLog() {
            const logContent = document.getElementById('log_content');
            logContent.innerHTML = '';
            
            actionLog.slice().reverse().forEach(log => {
                const p = document.createElement('p');
                p.innerHTML = `<span class="log-time">[${log.time}]</span> <span class="log-action">${log.action}</span>`;
                
                if (log.data) {
                    p.innerHTML += `<br><span class="log-data">${log.data.replace(/\\n/g, '<br>')}</span>`;
                }
                logContent.appendChild(p);
            });
            
            document.getElementById('log_modal').style.display = 'block';
        }

        function hideLog() {
            document.getElementById('log_modal').style.display = 'none';
        }

        function clearLog() {
            if (confirm("å®Ÿè¡Œãƒ­ã‚°ã€ãŠã‚ˆã³ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’æ¶ˆå»ã—ã€åˆæœŸçŠ¶æ…‹ã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ")) {
                actionLog = [];
                allSongsData = [];
                currentSongNumber = 1;
                localStorage.removeItem(STORAGE_KEY_SONGS);
                localStorage.removeItem(STORAGE_KEY_CURRENT_SONG);
                localStorage.removeItem(STORAGE_KEY_LOG);
                
                logAction('ã‚·ã‚¹ãƒ†ãƒ ', 'ã™ã¹ã¦ã®ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢');
                
                resetCurrentScores();
                updateOverallResultButtonStatus();
                document.getElementById('current_song_display').textContent = 1;

                showLog(); // ã‚¯ãƒªã‚¢å¾Œã®ãƒ­ã‚°ã‚’è¡¨ç¤º
            }
        }
        
        // ----------------------------------------------------
        // ğŸŒŸ ã‚²ãƒ¼ãƒ æ“ä½œé–¢é€£é–¢æ•° (ä¿å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ ) ğŸŒŸ
        // ----------------------------------------------------


        function setupArrowKeyNavigation() {
            const scoreInputs = Array.from(document.querySelectorAll('.player-score'));
            
            if (scoreInputs.length === 0) return;

            const rankIndexMap = RANKS.reduce((acc, rank, index) => {
                acc[rank] = index;
                return acc;
            }, {});

            document.addEventListener('keydown', (event) => {
                if (event.target.classList.contains('player-score')) {
                    
                    const currentInput = event.target;
                    const currentRank = currentInput.dataset.rank;
                    const currentPlayer = parseInt(currentInput.dataset.player);

                    let nextPlayer = currentPlayer;
                    let nextRankIndex = rankIndexMap[currentRank];
                    let shouldMove = false;

                    switch (event.key) {
                        case 'ArrowUp':
                            nextRankIndex = Math.max(0, nextRankIndex - 1);
                            shouldMove = true;
                            break;
                        case 'ArrowDown':
                            nextRankIndex = Math.min(RANKS.length - 1, nextRankIndex + 1);
                            shouldMove = true;
                            break;
                        case 'ArrowLeft':
                            nextPlayer = Math.max(1, currentPlayer - 1);
                            shouldMove = true;
                            break;
                        case 'ArrowRight':
                            nextPlayer = Math.min(NUM_PLAYERS, currentPlayer + 1);
                            shouldMove = true;
                            break;
                    }

                    if (shouldMove) {
                        event.preventDefault(); 
                        
                        const nextRank = RANKS[nextRankIndex];
                        const nextInput = document.querySelector(`.player-score[data-player="${nextPlayer}"][data-rank="${nextRank}"]`);
                        
                        if (nextInput) {
                            nextInput.focus();
                            nextInput.select(); 
                        }
                    }
                }
            });
        }

        function resetGame() {
            if (!confirm("ç¾åœ¨ã®æ›²ã®ãƒ‡ãƒ¼ã‚¿ã¨ã€ã™ã¹ã¦ã®è¨­å®šï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã€ç·æ›²æ•°ã€é…ç‚¹ï¼‰ã‚’åˆæœŸå€¤ã«æˆ»ã—ã¾ã™ã€‚æœ¬å½“ã«ã‚²ãƒ¼ãƒ ã‚’æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã—ã¾ã™ã‹ï¼Ÿ")) {
                return;
            }
            
            allSongsData = [];
            currentSongNumber = 1;
            document.getElementById('current_song_display').textContent = currentSongNumber;
            updateOverallResultButtonStatus();
            resetCurrentScores();
            
            // è¨­å®šå€¤ã‚‚ãƒªã‚»ãƒƒãƒˆ
            for (let i = 1; i <= NUM_PLAYERS; i++) {
                const inputElement = document.getElementById(`name_${i}`);
                const headerElement = document.getElementById(`header_p${i}_name`);
                inputElement.value = DEFAULT_NAMES[i - 1];
                headerElement.textContent = DEFAULT_NAMES[i - 1];
            }
            const totalSongsInput = document.getElementById('total_songs');
            totalSongsInput.value = DEFAULT_SONGS;
            document.getElementById('total_songs_display').textContent = DEFAULT_SONGS;
            RANKS.forEach(rank => {
                document.getElementById(`score_${rank}`).value = DEFAULT_SCORES[rank];
            });
            
            saveNames();
            saveSettings();
            saveData(); // ãƒ‡ãƒ¼ã‚¿ã‚’localStorageã«ä¿å­˜

            logAction('æ“ä½œ', 'ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã¨è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ'); 
            alert("ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã¨ã™ã¹ã¦ã®è¨­å®šãŒåˆæœŸå€¤ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚");
        }
        
        function updatePlayerCount() {
            const selected = parseInt(document.getElementById('player_count_select').value) || 5;
            const inputFields = document.querySelectorAll('.player-score, .player-col, [id^="header_p"]');
            
            for (let p = 1; p <= NUM_PLAYERS; p++) {
                const inputs = document.querySelectorAll(`.player-score[data-player="${p}"]`);
                const headerCol = document.getElementById(`header_p${p}_name`);
                const nameInput = document.getElementById(`name_${p}`);
                
                if (p > selected) {
                    inputs.forEach(el => el.style.display = 'none');
                    if (headerCol) headerCol.style.display = 'none';
                    if (nameInput) nameInput.parentElement.style.display = 'none';
                } else {
                    inputs.forEach(el => el.style.display = 'block');
                    if (headerCol) headerCol.style.display = 'block';
                    if (nameInput) nameInput.parentElement.style.display = 'block';
                }
            }
            logAction('è¨­å®š', `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’${selected}äººã«å¤‰æ›´`);
        }

        function undoSong() {
            if (allSongsData.length === 0) {
                alert("ã¾ã ç¢ºå®šã•ã‚ŒãŸã‚¹ã‚³ã‚¢ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                return;
            }
            
            const lastSong = currentSongNumber - 1;

            if (!confirm(`ç›´å‰ã® ${lastSong} æ›²ç›®ã®ã‚¹ã‚³ã‚¢ã‚’å‰Šé™¤ã—ã€ä¸€æ›²å‰ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }

            const deletedData = allSongsData.pop(); 
            currentSongNumber--;
            document.getElementById('current_song_display').textContent = currentSongNumber;
            updateOverallResultButtonStatus();
            resetCurrentScores();
            
            saveData(); // ãƒ‡ãƒ¼ã‚¿ã‚’localStorageã«ä¿å­˜

            logAction('æ“ä½œ', `${lastSong}æ›²ç›®ã‚’å…ƒã«æˆ»ã—ã¾ã—ãŸ`, deletedData.scores); 
            alert(`${currentSongNumber} æ›²ç›®ã®å…¥åŠ›ã«æˆ»ã‚Šã¾ã—ãŸã€‚`);
        }

        function updateOverallResultButtonStatus() {
            const totalSongs = parseInt(document.getElementById('total_songs').value) || 1;
            const overallButton = document.getElementById('show_result_button');
            
            if (allSongsData.length === totalSongs && totalSongs > 0) {
                overallButton.disabled = false;
            } else {
                overallButton.disabled = true;
            }
        }

        function resetCurrentScores() {
            const scoreInputs = document.querySelectorAll('.player-score');
            scoreInputs.forEach(input => {
                input.value = 0;
            });

            document.getElementById('intermediate_result_container').style.display = 'none';
            if (document.getElementById('result_screen').classList.contains('visible')) {
                showInputScreen();
            }
        }

        function confirmSongScore() {
            const totalSongs = parseInt(document.getElementById('total_songs').value) || 1;
            
            if (currentSongNumber > totalSongs) {
                alert(`ç·æ›²æ•°(${totalSongs}æ›²)ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚æ¬¡ã®æ›²ã¸é€²ã‚€å‰ã«ã€ç·åˆçµæœã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
                return;
            }

            const currentScores = getPlayerData();
            
            // ãƒãƒ¼ãƒ„æ•°ã¯è‡ªå‹•è¨ˆç®—ã•ã‚Œã‚‹ã®ã§ã€ãã®ã¾ã¾ç¢ºå®šã—ã¾ã™
            
            const totalScoreSum = currentScores.reduce((sum, p) => sum + p.totalScore, 0);
            if (totalScoreSum === 0 && !confirm("ã“ã®æ›²ã®ã‚¹ã‚³ã‚¢ã¯å…¨ã¦0ç‚¹ã§ã™ãŒã€ç¢ºå®šã—ã¦ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) {
                return;
            }
            
            // æ¥½æ›²åã‚’ä¿å­˜
            const songName = document.getElementById('song_name_input').value.trim();

            const songData = {
                song: currentSongNumber,
                songName: songName,
                scores: currentScores.map(p => ({
                    id: p.id,
                    name: p.name,
                    counts: p.counts,
                    totalScore: p.totalScore,
                    totalNotes: p.totalNotes
                }))
            };

            allSongsData.push(songData); 
            
            currentSongNumber++; 
            document.getElementById('current_song_display').textContent = currentSongNumber;
            updateOverallResultButtonStatus();
            resetCurrentScores();
            loadSongName(); // æ¬¡ã®æ›²ã®æ¥½æ›²åã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆç©ºã®å ´åˆãŒå¤šã„ï¼‰
            
            saveData(); // ãƒ‡ãƒ¼ã‚¿ã‚’localStorageã«ä¿å­˜

            logAction('æ“ä½œ', `${currentSongNumber - 1}æ›²ç›®ã®ã‚¹ã‚³ã‚¢ã‚’ç¢ºå®š (æ›²å: ${songName || 'ãªã—'})`, songData.scores);

            // OBSã¸ã®è‡ªå‹•åŒæœŸã¯è¡Œã‚ãªã„ï¼ˆæœ€çµ‚è¡¨ç¤ºãƒœã‚¿ãƒ³ã§åæ˜ ã™ã‚‹ä»•æ§˜ï¼‰

            let alertMessage = `${currentSongNumber - 1}æ›²ç›®ã®ã‚¹ã‚³ã‚¢ã‚’è¨˜éŒ²ã—ã¾ã—ãŸï¼\n\n`;
            
            const overallPlayerData = getOverallPlayerData(true); 
            
            if (currentSongNumber <= totalSongs) {
                 alertMessage += `æ¬¡ã® ${currentSongNumber} æ›²ç›®ã¸é€²ã¿ã¾ã™ã€‚\n\n`;
            } else {
                alertMessage += `ã“ã‚Œã§ç·æ›²æ•°ã«é”ã—ã¾ã—ãŸï¼\nã€ŒğŸ† å…¨æ›²ã®ç·åˆçµæœã‚’è¡¨ç¤ºã€ãƒœã‚¿ãƒ³ãŒæŠ¼ã›ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚`;
            }

            overallPlayerData.forEach(p => {
                const totalScore = overallPlayerData.find(data => data.id === p.id).totalScore;
                alertMessage += `${p.name}: ç·åˆ ${totalScore}ç‚¹\n`;
            });
            
            alert(alertMessage);
        }

        function getPlayerData() {
             const scores = {};
            RANKS.forEach(rank => {
                scores[rank] = parseInt(document.getElementById(`score_${rank}`).value) || 0;
            });

            const playerNames = {};
            for (let i = 1; i <= NUM_PLAYERS; i++) {
                playerNames[i] = document.getElementById(`name_${i}`).value || `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${i}`;
            }

            const allPlayerData = [];

            for (let p = 1; p <= NUM_PLAYERS; p++) {
                let totalScore = 0;
                const counts = {};
                let totalNotes = 0;

                RANKS.forEach(rank => {
                    const inputElement = document.querySelector(`.player-score[data-player="${p}"][data-rank="${rank}"]`);
                    const count = parseInt(inputElement ? inputElement.value : 0) || 0; 
                    counts[rank] = count;
                    totalNotes += count;
                    totalScore += count * scores[rank];
                });
                
                allPlayerData.push({
                    id: p,
                    name: playerNames[p],
                    counts: counts,
                    totalScore: totalScore,
                    totalNotes: totalNotes
                });
            }
            return allPlayerData;
        }


        function calculateIntermediateResults() {
             const allPlayerData = getPlayerData();
            const container = document.getElementById('intermediate_result_container');
            container.innerHTML = ''; 

            const table = document.createElement('table');
            table.id = 'intermediate_result_table';

            const thead = table.createTHead();
            let headerRow = thead.insertRow();
            headerRow.insertCell().textContent = 'åˆ¤å®š';

            allPlayerData.forEach((data) => {
                headerRow.insertCell().textContent = data.name;
            });
            
            const tbody = table.createTBody();

            RANKS.forEach(rank => {
                let row = tbody.insertRow();
                
                let rankCell = row.insertCell();
                rankCell.textContent = rank.charAt(0).toUpperCase() + rank.slice(1);
                rankCell.classList.add(RANK_CLASSES[rank]); 
                
                allPlayerData.forEach(data => {
                    let cell = row.insertCell();
                    cell.textContent = data.counts[rank];
                });
            });

            let totalRow = tbody.insertRow();
            totalRow.classList.add('total-row');
            
            totalRow.insertCell().textContent = 'TOTAL';
            
            allPlayerData.forEach(data => {
                let cell = totalRow.insertCell();
                cell.textContent = data.totalScore;
                cell.style.color = '#ff9900'; 
            });

            container.appendChild(table);
            container.style.display = 'block'; 
        }

        async function showFinalValues() {
            const tableContainer = document.getElementById('final_result_table_container');
            
            tableContainer.classList.add('show-value');
            document.getElementById('show_final_values_button').style.display = 'none';

            
            document.querySelectorAll('.first-place-column-cell, .single-song-highlight-cell').forEach(cell => {
                cell.classList.remove('first-place-column-cell', 'single-song-highlight-cell');
            });
            
            const title = document.getElementById('result_title').textContent;
            let dataForHighlight;
            let highlightType;

            if (title.includes('å˜ä½“çµæœ')) {
                dataForHighlight = getPlayerData();
                highlightType = 'single_song';
            } else {
                dataForHighlight = getOverallPlayerData();
                highlightType = 'overall';
            }
            
            highlightWinners(dataForHighlight, highlightType);
            
            logAction('æ“ä½œ', `${title}ã®æ•°å€¤ã‚’è¡¨ç¤º/ãƒã‚¤ãƒ©ã‚¤ãƒˆ`); 

            // OBSã¸åæ˜ ï¼šbuildResultOverlayHTMLã§è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½¿ã†
            try {
                if (obsConnected && obsWebSocket) {
                    // labelOnly=false ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨HTMLã‚’ç”Ÿæˆï¼ˆè‡ªå‹•çš„ã«ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒåŸ‹ã‚è¾¼ã¾ã‚Œã‚‹ï¼‰
                    const animatedHtml = buildResultOverlayHTML(dataForHighlight, highlightType === 'overall', false, false);
                    await obsWebSocket.setBrowserSourceHTML('result_overlay', animatedHtml);
                    addOBSLog('OBSã«æœ€çµ‚æ•°å€¤ã‚’åæ˜ ã—ã¾ã—ãŸ', 'success');
                } else {
                    addOBSLog('OBSæœªæ¥ç¶šã®ãŸã‚åæ˜ ã§ãã¾ã›ã‚“ã§ã—ãŸ', 'error');
                }
            } catch (e) {
                addOBSLog(`OBSåæ˜ ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
            }
        }

        function highlightWinners(data, type) {
            if (data.length === 0) return;

            const sortedData = [...data].sort((a, b) => b.totalScore - a.totalScore);
            const firstPlaceScore = sortedData[0].totalScore > 0 ? sortedData[0].totalScore : -1; 
            
            const firstPlacePlayerIds = data
                .filter(pData => pData.totalScore === firstPlaceScore)
                .map(pData => pData.id);

            if (firstPlacePlayerIds.length > 0) {
                const table = document.getElementById('final_result_table');
                if (table) {
                    const allRows = table.querySelectorAll('tbody tr');

                    data.forEach((pData, index) => {
                        if (firstPlacePlayerIds.includes(pData.id)) {
                            const columnIndex = index + 1; 

                            allRows.forEach(row => {
                                const cell = row.cells[columnIndex];
                                
                                if (cell) {
                                    if (type === 'overall') {
                                        if (row.matches('.total-row') || row.matches('.count-total-row')) {
                                             cell.classList.add('first-place-column-cell');
                                        }
                                    } else if (type === 'single_song') {
                                        if (row.matches('.total-row') || !row.querySelector('td:first-child').classList.contains('total-row')) {
                                            if (row.matches('.total-row')) {
                                                cell.classList.add('first-place-column-cell'); 
                                            } else {
                                                cell.classList.add('single-song-highlight-cell'); 
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            }
        }

        async function calculateAndShowSingleSongResult() {
            const allPlayerData = getPlayerData();
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚»ãƒ¬ã‚¯ã‚¿ã«åŸºã¥ãæœ‰åŠ¹ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ã‚’æ¯”è¼ƒ
            const playerCountSel = document.getElementById('player_count_select');
            const activeCount = playerCountSel ? parseInt(playerCountSel.value) || NUM_PLAYERS : NUM_PLAYERS;
            const activePlayers = allPlayerData.slice(0, activeCount);

            // å…¨å“¡ã® totalNotes ãŒä¸€è‡´ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (activePlayers.length > 0) {
                const firstNotes = activePlayers[0].totalNotes || 0;
                const mismatches = activePlayers.filter(p => (p.totalNotes || 0) !== firstNotes);
                if (mismatches.length > 0) {
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºï¼‹ã‚¢ãƒ©ãƒ¼ãƒˆã§é€šçŸ¥ã—ã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯
                    mismatches.forEach(p => {
                        const notesEl = document.getElementById(`notes_${p.id}`);
                        if (notesEl) {
                            notesEl.style.border = '2px solid #dc3545';
                            notesEl.style.boxShadow = '0 0 6px rgba(220,53,69,0.6)';
                        }
                    });
                    setTimeout(() => {
                        mismatches.forEach(p => {
                            const notesEl = document.getElementById(`notes_${p.id}`);
                            if (notesEl) {
                                notesEl.style.border = '';
                                notesEl.style.boxShadow = '';
                            }
                        });
                    }, 3000);

                    alert('ãƒãƒ¼ãƒ„æ•°ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–“ã§ä¸€è‡´ã—ã¦ã„ã¾ã›ã‚“ã€‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“ã€‚\n\n' +
                        mismatches.map(p => `${p.name}: ${p.totalNotes} ãƒãƒ¼ãƒ„`).join('\n'));
                    return;
                }
            }
            const songTitle = `æ›²ç›® ${currentSongNumber} ã®å˜ä½“çµæœ`;
            generateResultTable(allPlayerData, songTitle, 'single_song');
            toggleScreens(false);
            logAction('æ“ä½œ', songTitle, allPlayerData.map(p => `${p.name}: ${p.totalScore}ç‚¹`));

            // OBSã‚·ãƒ¼ãƒ³ã‚’çµæœè¡¨ç¤ºç”¨ã«åˆ‡ã‚Šæ›¿ãˆã€ãƒ©ãƒ™ãƒ«ã®ã¿ã®åˆæœŸã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é€ä¿¡
            if (obsConnected && obsWebSocket) {
                try {
                    await obsWebSocket.setSceneName('OBS-Results');
                    addOBSLog('OBSã‚·ãƒ¼ãƒ³ã‚’ OBS-Results ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ', 'info');
                    
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã¯ãƒ©ãƒ™ãƒ«ã®ã¿ã‚’è¡¨ç¤º
                    if (document.getElementById('obs_show_results').checked) {
                        const labelOnlyHtml = buildResultOverlayHTML(allPlayerData, false, false, true);
                        await obsWebSocket.setBrowserSourceHTML('result_overlay', labelOnlyHtml);
                        addOBSLog('OBSã«ãƒ©ãƒ™ãƒ«è¡¨ç¤ºã‚’é€ä¿¡ã—ã¾ã—ãŸ', 'info');
                    }
                } catch (e) {
                    addOBSLog(`OBSã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆå¤±æ•—: ${e.message}`, 'error');
                }
            }
        }

        async function calculateAndShowOverallResults() {
            if (allSongsData.length === 0) {
                alert("ã¾ã ç¢ºå®šã•ã‚ŒãŸæ›²ã®ã‚¹ã‚³ã‚¢ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                return;
            }
            
            const overallPlayerData = getOverallPlayerData();
            generateResultTable(overallPlayerData, 'ç·åˆçµæœ', 'overall');
            toggleScreens(false);
            logAction('æ“ä½œ', 'ç·åˆçµæœã‚’è¡¨ç¤º', overallPlayerData.map(p => `${p.name}: ${p.totalScore}ç‚¹`));

            // OBSã‚·ãƒ¼ãƒ³ã‚’çµæœè¡¨ç¤ºç”¨ã«åˆ‡ã‚Šæ›¿ãˆã€ãƒ©ãƒ™ãƒ«ã®ã¿ã®åˆæœŸã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é€ä¿¡
            if (obsConnected && obsWebSocket) {
                try {
                    await obsWebSocket.setSceneName('OBS-Results');
                    addOBSLog('OBSã‚·ãƒ¼ãƒ³ã‚’ OBS-Results ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ', 'info');
                    
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã¯ãƒ©ãƒ™ãƒ«ã®ã¿ã‚’è¡¨ç¤º
                    if (document.getElementById('obs_show_results').checked) {
                        const labelOnlyHtml = buildResultOverlayHTML(overallPlayerData, true, false, true);
                        await obsWebSocket.setBrowserSourceHTML('result_overlay', labelOnlyHtml);
                        addOBSLog('OBSã«ãƒ©ãƒ™ãƒ«è¡¨ç¤ºã‚’é€ä¿¡ã—ã¾ã—ãŸ', 'info');
                    }
                } catch (e) {
                    addOBSLog(`OBSã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆå¤±æ•—: ${e.message}`, 'error');
                }
            }
        }

        function getOverallPlayerData() {
            const overallResults = {};

            for (let p = 1; p <= NUM_PLAYERS; p++) {
                overallResults[p] = {
                    id: p,
                    name: document.getElementById(`name_${p}`).value || `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${p}`,
                    totalScore: 0,
                    songScores: [],
                    totalCounts: {}
                };
                RANKS.forEach(rank => overallResults[p].totalCounts[rank] = 0);
            }

            allSongsData.forEach((song) => {
                song.scores.forEach(playerScore => {
                    const pId = playerScore.id;
                    overallResults[pId].totalScore += playerScore.totalScore; 
                    
                    overallResults[pId].songScores.push({
                        song: song.song,
                        score: playerScore.totalScore
                    });

                    RANKS.forEach(rank => {
                        overallResults[pId].totalCounts[rank] += playerScore.counts[rank];
                    });
                });
            });
            
            return Object.values(overallResults);
        }

        function generateResultTable(data, title, type) {
            const container = document.getElementById('final_result_table_container');
            container.innerHTML = ''; 
            document.getElementById('result_title').textContent = title;

            // æ•°å­—ã‚’å¿…ãšéš ã™çŠ¶æ…‹ã«åˆæœŸåŒ–
            container.classList.remove('show-value');
            document.querySelectorAll('.hidden-value').forEach(el => {
                el.style.visibility = 'hidden';
            });
            document.getElementById('show_final_values_button').style.display = 'block';

            const table = document.createElement('table');
            table.id = 'final_result_table';

            const thead = table.createTHead();
            let headerRow = thead.insertRow();
            headerRow.insertCell().textContent = (type === 'overall') ? 'åˆ¤å®š/ç·åˆ' : 'åˆ¤å®š';

            data.forEach((pData) => {
                let headerCell = headerRow.insertCell();
                let nameSpan = document.createElement('span');
                nameSpan.textContent = pData.name;
                headerCell.appendChild(nameSpan);
            });
            
            const tbody = table.createTBody();

            if (type === 'overall') {
                
                RANKS.forEach(rank => {
                    let row = tbody.insertRow();
                    row.classList.add('count-total-row');
                    
                    let rankCell = row.insertCell();
                    rankCell.textContent = `${rank.charAt(0).toUpperCase() + rank.slice(1)} å›æ•°`;
                    
                    data.forEach(pData => {
                        let cell = row.insertCell();
                        let valueSpan = document.createElement('span');
                        valueSpan.classList.add('hidden-value');
                        valueSpan.textContent = pData.totalCounts[rank]; 
                        cell.appendChild(valueSpan);
                    });
                });

                let totalRow = tbody.insertRow();
                totalRow.classList.add('total-row');
                
                totalRow.insertCell().textContent = 'ç·åˆ TOTAL';
                
                data.forEach(pData => {
                    let cell = totalRow.insertCell();
                    let valueSpan = document.createElement('span');
                    valueSpan.classList.add('hidden-value');
                    valueSpan.textContent = pData.totalScore;
                    cell.appendChild(valueSpan);
                });

            } else if (type === 'single_song') {
                
                RANKS.forEach(rank => {
                    let row = tbody.insertRow();
                    
                    let rankCell = row.insertCell();
                    rankCell.textContent = rank.charAt(0).toUpperCase() + rank.slice(1);
                    rankCell.classList.add(RANK_CLASSES[rank]); 
                    
                    data.forEach(playerData => {
                        let cell = row.insertCell();
                        let valueSpan = document.createElement('span');
                        valueSpan.classList.add('hidden-value');
                        valueSpan.textContent = playerData.counts[rank];
                        cell.appendChild(valueSpan);
                    });
                });

                let totalRow = tbody.insertRow();
                totalRow.classList.add('total-row');

                totalRow.insertCell().textContent = 'TOTAL';
                
                data.forEach(pData => {
                    let cell = totalRow.insertCell();
                    let valueSpan = document.createElement('span');
                    valueSpan.classList.add('hidden-value');
                    valueSpan.textContent = pData.totalScore;
                    cell.appendChild(valueSpan);
                });
            }

            container.appendChild(table);
            // ä½µã›ã¦ã‚°ãƒ©ãƒ•ã‚£ã‚«ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
            renderGraphicResult(data, type);
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã¯OBSã«é€ä¿¡ã—ãªã„ï¼ˆãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ã®ã¿é€ä¿¡ï¼‰
        }

        function renderGraphicResult(data, type) {
            const container = document.getElementById('graphic_result_container');
            container.innerHTML = '';

            if (!data || data.length === 0) return;

            const wrapper = document.createElement('div');
            wrapper.className = 'graphic-result';

            // ãƒ©ãƒ™ãƒ«åˆ—
            const labelCol = document.createElement('div');
            labelCol.className = 'label-col';
            const labels = ['PERFECT', 'GREAT', 'GOOD', 'BAD', 'MISS', 'TOTAL'];
            labels.forEach(lbl => {
                const span = document.createElement('div');
                span.className = 'graphic-label';
                span.textContent = lbl;
                labelCol.appendChild(span);
            });
            wrapper.appendChild(labelCol);

            // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ—
            // data ã¯æ—¢ã«ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹æƒ³å®šï¼ˆgenerateå´ã§ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ï¼‰
            data.forEach(pData => {
                const col = document.createElement('div');
                col.className = 'player-col';

                const nameEl = document.createElement('div');
                nameEl.className = 'graphic-player-name';
                nameEl.textContent = pData.name || `P${pData.id}`;
                col.appendChild(nameEl);

                const counts = pData.counts || pData.totalCounts || {};

                // PERFECT
                const perf = document.createElement('div');
                perf.className = 'graphic-count';
                perf.textContent = String(counts.perfect || 0);
                col.appendChild(perf);

                // GREAT
                const great = document.createElement('div');
                great.className = 'graphic-count';
                great.textContent = String(counts.great || 0);
                col.appendChild(great);

                // GOOD
                const good = document.createElement('div');
                good.className = 'graphic-count';
                good.textContent = String(counts.good || 0);
                col.appendChild(good);

                // BAD
                const bad = document.createElement('div');
                bad.className = 'graphic-count';
                bad.textContent = String(counts.bad || 0);
                col.appendChild(bad);

                // MISS
                const miss = document.createElement('div');
                miss.className = 'graphic-count';
                miss.textContent = String(counts.miss || 0);
                col.appendChild(miss);

                // TOTAL
                const total = document.createElement('div');
                total.className = 'graphic-count graphic-total';
                total.textContent = String(pData.totalScore || 0);
                col.appendChild(total);

                wrapper.appendChild(col);
            });

            container.appendChild(wrapper);
        }

        function buildResultOverlayHTML(data, isOverall, animate = false, labelOnly = false) {
            // ãƒ†ãƒ¼ãƒ–ãƒ«å½¢å¼ã®HTMLã‚’ç”Ÿæˆï¼ˆOBSã®Browser Sourceå‘ã‘ï¼‰
            // ãƒ©ãƒ™ãƒ«åˆ—ï¼ˆPERFECTç­‰ï¼‰ã‚’å‰Šé™¤ã—ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ—ã®ã¿è¡¨ç¤º
            const playerCount = data.length;
            const tableWidth = (playerCount * 180); // player col only
            
            // respect user's theme selection (saved in localStorage) so overlay matches light/dark
            const theme = (localStorage && localStorage.getItem && localStorage.getItem('pjskaiAggregation_theme')) || 'dark';
            const colors = theme === 'light' ? {
                bodyText: '#111',
                headerText: '#111',
                border: '#ddd',
                countText: '#000',
                countBg: '#fff',
                totalText: '#000',
                totalBg: '#ffd700',
                totalBorder: '#ccc'
            } : {
                bodyText: '#fff',
                headerText: '#000',
                border: '#333',
                countText: '#000',
                countBg: '#fff',
                totalText: '#000',
                totalBg: '#ffd700',
                totalBorder: '#444'
            };

            const style = 'html,body{margin:0;padding:0;background:rgba(0,0,0,0);font-family:"Arial",sans-serif;color:' + colors.bodyText + '}' +
                '.wrap{width:' + tableWidth + 'px;height:100%;margin:0;padding:0;overflow:hidden}' +
                'table{width:100%;border-collapse:collapse}' +
                'thead{background:rgba(0,0,0,0)}' +
                'thead th{padding:14px 10px;text-align:center;color:' + colors.headerText + ';font-weight:700;font-size:18px;border:1px solid ' + colors.border + ';background:rgba(0,0,0,0)}' +
                'tbody td{padding:12px 8px;text-align:center;border:1px solid ' + colors.border + ';vertical-align:middle;font-size:16px;background:rgba(0,0,0,0)}' +
                '.count{font-weight:800;font-size:32px;color:' + colors.countText + ';background:' + colors.countBg + ';border-radius:8px;padding:8px 12px;display:inline-block;min-width:60px;text-shadow:none}' +
                '.total{font-size:36px;color:' + colors.totalText + ';background:' + colors.totalBg + ';border-radius:8px;padding:10px 14px;display:inline-block;font-weight:900;box-shadow:0 4px 8px rgba(0,0,0,0.3)}' +
                '.total-row{border-top:2px solid ' + colors.totalBorder + '}' +
                '.total-row td{font-weight:900;background:rgba(0,0,0,0)}' +
                '.winner{position:relative}' +
                '.winner .count,.winner .total{position:relative;z-index:1}' +
                '.pulse .count,.pulse .total{animation:pulse 0.7s cubic-bezier(0.4, 0, 0.6, 1) infinite !important}' +
                '@keyframes pulse{0%{box-shadow:0 0 0 0 rgba(255,215,0,1);transform:scale(1)}50%{box-shadow:0 0 0 15px rgba(255,215,0,0);transform:scale(1.08)}100%{box-shadow:0 0 0 0 rgba(255,215,0,0);transform:scale(1)}}' +
                'body,html{height:100%;width:100%}';

            // header row (player names only - no label column)
            const headers = data.map(p => '<th>' + escapeHtml(p.name||('P'+p.id)) + '</th>').join('');

            // determine winners (highest totalScore)
            const maxScore = Math.max(...data.map(p => p.totalScore || 0));
            const winners = data.map(p => (p.totalScore || 0) === maxScore);

            // Build actual data cells (for roulette)
            const ranks = ['perfect','great','good','bad','miss'];
            const actualValues = [];
            const totalValues = [];
            
            ranks.forEach(rank => {
                const rankValues = [];
                data.forEach((p, idx) => {
                    const val = p.counts?.[rank] ?? p.totalCounts?.[rank] ?? 0;
                    rankValues.push(val);
                });
                actualValues.push(rankValues);
            });
            
            data.forEach((p, idx) => {
                totalValues.push(p.totalScore ?? 0);
            });

            // Combine all rank rows into one table (no label column)
            const rowsHtml = ranks.map((rank, rankIdx) => {
                const cells = data.map((p, idx) => {
                    const val = actualValues[rankIdx][idx];
                    const cls = winners[idx] ? 'winner' : '';
                    if (labelOnly) {
                        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ï¼šæ•°å­—ã¯è¦‹ãˆãªã„
                        return '<td class="' + cls + '"><span class="count" style="visibility:hidden;"></span></td>';
                    } else {
                        return '<td class="' + cls + '"><span class="count">' + val + '</span></td>';
                    }
                }).join('');
                return '<tr>' + cells + '</tr>';
            }).join('');

            // total row 
            const totalCells = data.map((p, idx) => {
                const cls = winners[idx] ? 'winner' : '';
                const val = totalValues[idx];
                if (labelOnly) {
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ï¼šæ•°å­—ã¯è¦‹ãˆãªã„
                    return '<td class="' + cls + '"><span class="total" style="visibility:hidden;"></span></td>';
                } else {
                    return '<td class="' + cls + '"><span class="total">' + val + '</span></td>';
                }
            }).join('');

            let scriptPart = '';
            if (!labelOnly) {
                // ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆç”¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã«ã¯ä»˜ã‘ãªã„ï¼‰
                scriptPart = '<script>' +
                    'window.addEventListener("load",function(){' +
                    'var rand=function(){return Math.floor(Math.random()*9999)+1};' +
                    'var els=document.querySelectorAll(".count, .total");' +
                    'var iv=setInterval(function(){els.forEach(function(el){el.textContent=rand();});},50);' +
                    'var actualValues=' + JSON.stringify(actualValues) + ';' +
                    'var totalValues=' + JSON.stringify(totalValues) + ';' +
                    'setTimeout(function(){' +
                    'clearInterval(iv);' +
                    'var cellIdx=0;' +
                    'actualValues.forEach(function(rankVals){rankVals.forEach(function(v){if(els[cellIdx]){els[cellIdx].textContent=v;}cellIdx++;});});' +
                    'totalValues.forEach(function(v,i){if(els[cellIdx]){els[cellIdx].textContent=v;}cellIdx++;});' +
                    'var winners=document.querySelectorAll(".winner");' +
                    'winners.forEach(function(w){w.classList.add("pulse");});' +
                    '},2500);' +
                    '});' +
                    '<' + '/script>';
            }

            const html = '<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><style>' + style + '</style></head><body><div class="wrap"><table><thead><tr>' + headers + '</tr></thead><tbody>' + rowsHtml + '<tr class="total-row">' + totalCells + '</tr></tbody></table></div>' + scriptPart + '</body></html>';
            return html;
        }

        function escapeHtml(s){
            if (!s) return '';
            return String(s).replace(/[&<>\"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c]));
        }

        function showInputScreen() {
            toggleScreens(true);
            document.getElementById('intermediate_result_container').style.display = 'none';
            
            // OBS ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’éè¡¨ç¤ºã«ã™ã‚‹
            if (obsConnected && obsWebSocket) {
                try {
                    obsWebSocket.setSourceText('result_overlay', '');
                    addOBSLog('result_overlayã‚’éè¡¨ç¤ºã«ã—ã¾ã—ãŸ', 'info');
                } catch (e) {
                    // result_overlay ãŒãƒ†ã‚­ã‚¹ãƒˆã‚½ãƒ¼ã‚¹ã§ãªã„å ´åˆã€ä½•ã‚‚ã—ãªã„
                }
            }
            
            // ğŸ¥ OBS ã‚·ãƒ¼ãƒ³å¾©å¸°
            if (document.getElementById('obs_hide_results').checked && obsConnected && obsWebSocket) {
                obsWebSocket.setSceneName('OBS-Input');
            }
        }

        function toggleScreens(showInput) {
            const inputScreen = document.getElementById('input_screen');
            const resultScreen = document.getElementById('result_screen');

            if (!showInput) {
                resultScreen.style.display = 'block'; 
                inputScreen.style.display = 'none'; 
                
                setTimeout(() => {
                    resultScreen.classList.add('visible');
                }, 10);
            } else {
                resultScreen.classList.remove('visible');
                
                setTimeout(() => {
                    resultScreen.style.display = 'none'; 
                    inputScreen.style.display = 'block'; 
                }, 500); 
            }
        }
    </script>
</body>
</html>